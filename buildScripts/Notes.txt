Servers
- Express
  (Lightwieght, highly configurable, not just for static files, production ready. Great for not)
  Competitors
  - Koa
  - Hapi
  All good for serverside node apps.

- Webpack (comes with inbuilt server)
- http-server (Simpliest, Lightweight .. no config)
- live-server (Lightweight ... live reloading)
- browsersync

Your decision for server may also be dependent on your bundler as they often come with their own server or
with support for particular servers. Budo is great to browserify (includes hot reloading)
Webpack comes with its own webserver. Serves app from memory

- Browsersync: free webserver. Sets up dedicated IP on LAN. Can sync all changes across varios access point.
great for cross browser testing.

Sharing Work In progress

- localtunnel (easiest install. punches hole through firewall to expose local machine port. Ultra versatile)
- ngrok (requires a few extra steps to sort. ngrok is more secure. Password protection)
- now (publishes up to an actual web server, deploys up to the cloud. Does not punch hole in firework. Only host static files)
- surge (supoort only static html and js)


Using localtunnel

- npm install localtunnel -g (install globally)
- lt --port 3000 --subdomain ogisi (subdomain optional but creates better urls)


Automation (Task Runners)

- Grunt (configuration driven, less code)
- Gulp (using pipe, does not write to disc. Code based, write code, does not write files to disk,
        you write actual javascript code)
- npm: Declared in script section of package.json file. Great for cross platform Automation
       Grants access to all the functionality of command line
       Access to all the commandline functionality
       Even call sepate scripts that use node
       Use tools/packages directly rather than through abstraction layer like grunt or Gulp
       No need for separate plugin
       Simpler debugging
       Better docs
       Simple


Transpiler
Over 100 languages that transpile into javascript
Key transpilers
- Babel
1.  Enjoy all the new features of JS, even the experimental one.
Transpiles them down to ES5
11. Write with standardized JS
111. This means you can use it out of the box with other mnodule
iv. eg react and ESlint did not support typscript for a while
v. Due to the power of ides like visual code along with lint
and great libs most of the advantages of Typescript may not beneeded

- TypeScript
1. Superset of JS
11. Enhanced autocompletion
111. Add type annotation to JS which add type safety which
enables Enhanced autocompletion.
iv. Clarifies developer intent
v. Enhanced readability
vi. Addtional features like interfaces
vi Requires type definition files and annotations for
autocompletion to work

- Elm
i. Nothing like js
ii. compiles down to JS
iii. Immutable data structures
iv. Friendly errors
v. All errors are compile-time errors
vi. Interops with JS
v. Requires team to learn new lanaguage



BABEL:

Configuration
- Package.json (Advantage: one less file in your project)
- .babelrc (Advantage is that its not npm specific)

Transpile vs ES5

ES5
No waiting for transpile = faster
No transpiler dependency


Transpile
Enojoy the lastest features
Consistent coding style
Use the same linting rules everywhere
As node features increase eventually remove transpiler


ES6 Modules

- Standardized: no need to transpile  your code when platforms become compactible with ES6. Also easy
for new developers to come up to speed
- Statically Analyzable:
  - Cannot be declared dynamically. Code can be read and analyzed in a predictable
  because imports cannot be changed at runtime. This means there is improved autocomplete support and
  Intelligent refactoring
  - Fails fast
  - Tree shaking

- Easy to read
  - Named imports
  - Default imports


  BUNDLER:

