Servers
- Express
  (Lightwieght, highly configurable, not just for static files, production ready. Great for not)
  Competitors
  - Koa
  - Hapi
  All good for serverside node apps.

- Webpack (comes with inbuilt server)
- http-server (Simpliest, Lightweight .. no config)
- live-server (Lightweight ... live reloading)
- browsersync

Your decision for server may also be dependent on your bundler as they often come with their own server or
with support for particular servers. Budo is great to browserify (includes hot reloading)
Webpack comes with its own webserver. Serves app from memory

- Browsersync: free webserver. Sets up dedicated IP on LAN. Can sync all changes across varios access point.
great for cross browser testing.

Sharing Work In progress

- localtunnel (easiest install. punches hole through firewall to expose local machine port. Ultra versatile)
- ngrok (requires a few extra steps to sort. ngrok is more secure. Password protection)
- now (publishes up to an actual web server, deploys up to the cloud. Does not punch hole in firework. Only host static files)
- surge (supoort only static html and js)


Using localtunnel

- npm install localtunnel -g (install globally)
- lt --port 3000 --subdomain ogisi (subdomain optional but creates better urls)


Automation (Task Runners)

- Grunt (configuration driven, less code)
- Gulp (using pipe, does not write to disc. Code based, write code, does not write files to disk,
        you write actual javascript code)
- npm: Declared in script section of package.json file. Great for cross platform Automation
       Grants access to all the functionality of command line
       Access to all the commandline functionality
       Even call sepate scripts that use node
       Use tools/packages directly rather than through abstraction layer like grunt or Gulp
       No need for separate plugin
       Simpler debugging
       Better docs
       Simple


Transpiler
Over 100 languages that transpile into javascript
Key transpilers
- Babel
1.  Enjoy all the new features of JS, even the experimental one.
Transpiles them down to ES5
11. Write with standardized JS
111. This means you can use it out of the box with other mnodule
iv. eg react and ESlint did not support typscript for a while
v. Due to the power of ides like visual code along with lint
and great libs most of the advantages of Typescript may not beneeded

- TypeScript
1. Superset of JS
11. Enhanced autocompletion
111. Add type annotation to JS which add type safety which
enables Enhanced autocompletion.
iv. Clarifies developer intent
v. Enhanced readability
vi. Addtional features like interfaces
vi Requires type definition files and annotations for
autocompletion to work

- Elm
i. Nothing like js
ii. compiles down to JS
iii. Immutable data structures
iv. Friendly errors
v. All errors are compile-time errors
vi. Interops with JS
v. Requires team to learn new lanaguage



BABEL:

Configuration
- Package.json (Advantage: one less file in your project)
- .babelrc (Advantage is that its not npm specific)

Transpile vs ES5

ES5
No waiting for transpile = faster
No transpiler dependency


Transpile
Enojoy the lastest features
Consistent coding style
Use the same linting rules everywhere
As node features increase eventually remove transpiler


ES6 Modules

- Standardized: no need to transpile  your code when platforms become compactible with ES6. Also easy
for new developers to come up to speed
- Statically Analyzable:
  - Cannot be declared dynamically. Code can be read and analyzed in a predictable
  because imports cannot be changed at runtime. This means there is improved autocomplete support and
  Intelligent refactoring
  - Fails fast
  - Tree shaking

- Easy to read
  - Named imports
  - Default imports


  BUNDLER:

  Take all your JS files and intelligently package them for a target environment e.g browser or node


Require JS: Popularized the AMD pattern. Has fallen out of favour. ES6 is the future


Options:

- Browserify
  - first bundler to reach mass adoption
  - Bundle npm packages for the web
  - bundles code that uses common js pattern
  - its design is plugin based
  SIMPLE
    - means you have to do more stuff for yourself. (CAn be use with rollup)

- Webpack
  - more than just JS
  - can handle css, images etc like JS
  - Can even inline styles if they are small enough
  - Built in hot-reloading web server

  COMPREHENSIVE. MOST FULL FEATURED
  ABILITY TO INTELLIGENTLY BUNDLE GENERATE YOUR CSS, IMAGES, FONTS, HTML. MEANS YOU CAN
  INLINE IMAGES VIA BASE64 ENCODING WHEN SMALL ENOUGH TO JUSTIFY SAVING IN HTTP REQUESTS AND
  HOT RELOAD CSS CHANAGES VIA BUILT IN WEBSERVER

  STRATEGIC BUNDLE SPLITTING SO YOU ARE ONLY LOADING WHEN NEEDED
  HOT MODULE RELOADING

- Rollup
  - first to offer tree shaking. Removes stuff you dont need
  - faster loading production code
    this is because webpack and browserify have to inline a module loader
    but rollup moves all code into the same scope
  - Quite new
  - Great for library authors
  - No hot reloading and code splitting yet so may not be ideal for apps

  TREE SHAKING AND PERFORMANCE BUT NEW SO MAKES MORE SENSE TO USE IT with
  TOOLS LIKE JSPM AND BROWSERIFY OR USE BY ITSELF IF YOU ARE A LIBRARY AURTHOR
  WEBPACK 2 WILL OFFER TREE SHAKING

- JSPM
  - Uses SystemJS, a universial module loader
  - bundles code at runtime rather than at compile time like webpack and browserify
  - has its own package managaer
  - Can install from npm, git
  - Uses Rollup

  RUNTIME LOADER AND ONLY ONE WITH PACKAGE MANAGER

Sourcemaps 

Allows you to debug mimified/bundled JS script by 
Downloading the plain js files when the dev tools
window is opened.


LINTERS

- Enforce consistency and avoid mistakes
 Options

- JSLint
- JS Hint (improvement on JSLint)
- ESLint (Defacto standard)

*Note: If you are working with typescript you will 
need to use TSLint for now as ESlint does not support
TypeScript.

Core Decisions for configuring ESlint
- COnfig Format?
  - .eslintrc
- Which Built-in rules?
  - decide with team what rules to enable
- Warnings or errors?
  - Warning do not break build
  - Errors break build. Cant be ignored
  - use both. wanring for minor stylistic issues
  and errors for larger things. Some rules for error
  and some for errors

- Which plugins?
  - eslint-plugin-react

- Use presets instead?
  - Comes with presets.
  - ue standard for base and then tweak
  - or use existing like airbnb and standardjs
  

  No Watch setting for ESlint. 2 Options

  - ESLint-loader
    - Re-lints all files upon save (tied to webpack) 

  - ESLint-watch
    - Wrapper around ESLint that adds file watch
    - Not tied to webpack
    - Better warning/error formatting
    - display clean message
    - Easily lint all files including tests and build scripts

  ESLint does not support js experimental features.
  FOr that you need to use babel-eslint









